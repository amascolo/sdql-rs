// TODO clean up – was generated by o-1 https://chatgpt.com/c/67dad45d-8e28-8000-82dd-21dc9e9a4cf3
//  and it was cleaned up by o4-mini-high https://chatgpt.com/c/6808e517-5464-8000-bca7-452bbf131911

use proc_macro::TokenStream;
use proc_macro2::{Span, TokenStream as TokenStream2};
use quote::quote;
use syn::{
    parse::{Parse, ParseStream, Parser},
    punctuated::Punctuated,
    spanned::Spanned,
    token, Error as SynError, ExprMacro, Ident, LitBool, LitFloat, LitInt, LitStr, Token,
};

/// The user-facing macro. We'll detect if the input is `include!(...)` or `include!(concat!(...))`,
/// read the file ourselves, parse it as DSL, otherwise fallback to normal DSL parse.
#[proc_macro]
pub fn sdql_static(input: TokenStream) -> TokenStream {
    // Convert to proc_macro2 for ergonomics
    let ts2: TokenStream2 = input.clone().into();

    // 1) Try to expand include!(...) or include!(concat!(…))
    let expanded = try_expand_include(&ts2).unwrap_or(ts2);

    // 2) Now parse the DSL or emit an error
    match syn::parse2::<SdqlValue>(expanded.clone()) {
        Ok(ast) => ast.into_token_stream().into(),
        Err(err) => err.to_compile_error().into(),
    }
}

/// Detect `include!(...)` or `include!(concat!(...))`, read the file, and return its tokens.
fn try_expand_include(ts: &TokenStream2) -> Option<TokenStream2> {
    // Parse the input as an ExprMacro (i.e. something of the form foo!(...))
    let expr_mac: ExprMacro = syn::parse2(ts.clone()).ok()?;
    if !expr_mac.mac.path.is_ident("include") {
        return None;
    }
    // Grab the tokens inside include!(...)
    let inner = expr_mac.mac.tokens.clone();
    // Try to get a path string from either a LitStr or concat!(...)
    let path = parse_path_literal_or_concat(inner).ok()?;
    // Read the file at compile time and parse as tokens
    read_file_to_tokens(&path).ok()
}

/// Parse either `"foo.sql"` or `concat!("part1", "part2")` into a single `String`.
fn parse_path_literal_or_concat(ts: TokenStream2) -> syn::Result<String> {
    // Case A: single string literal
    if let Ok(litstr) = syn::parse2::<LitStr>(ts.clone()) {
        return Ok(litstr.value());
    }
    // Case B: an ExprMacro whose path is "concat"
    let mac: ExprMacro = syn::parse2(ts)?;
    if !mac.mac.path.is_ident("concat") {
        return Err(SynError::new(mac.mac.path.span(), "expected `concat!(…)`"));
    }
    // Parse the inside of concat!(...) as comma-separated LitStr
    let parser = Punctuated::<LitStr, Token![,]>::parse_terminated;
    let groups = parser.parse2(mac.mac.tokens.clone()).map_err(|e| {
        SynError::new(
            mac.mac.tokens.span(),
            format!("invalid `concat!(…)` args: {}", e),
        )
    })?;
    Ok(groups.into_iter().map(|s| s.value()).collect())
}

/// Read a file at compile time and parse it as a TokenStream
fn read_file_to_tokens(path: &str) -> Result<TokenStream2, SynError> {
    use std::fs;
    let content = fs::read_to_string(path).map_err(|e| {
        SynError::new(
            Span::call_site(),
            format!("failed to read file `{}`: {}", path, e),
        )
    })?;
    content
        .parse::<TokenStream2>()
        .map_err(|e| SynError::new(Span::call_site(), format!("token parse error: {}", e)))
}

/// Internal AST for our DSL. (No derive to avoid issues with Lit*.)
enum SdqlValue {
    /// e.g. `{ key -> value, key2 -> value2, ... }`
    Map(Vec<(SdqlValue, SdqlValue)>),

    /// e.g. `<val1, val2, ...>` => `Record::new((val1, val2, ...))`
    Record(Vec<SdqlValue>),

    /// e.g. `date(12345)` => `date!(12345)`
    Date(LitInt),

    /// booleans => `TRUE` / `FALSE`
    Bool(bool),

    /// integer literal => e.g. `10691`
    Int(LitInt),

    /// float literal => e.g. `3.14` => `OrderedFloat(3.14)`
    Float(LitFloat),

    /// negative integer => e.g. `-123`
    NegativeInt(LitInt),

    /// negative float => e.g. `-3.14`
    NegativeFloat(LitFloat),

    /// string literal => `"CHINA"` => `VarChar::from("CHINA").unwrap()`
    StringLit(LitStr),
}

impl Parse for SdqlValue {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        // 1) If braces => parse a map: { k -> v, ... }
        if input.peek(token::Brace) {
            return parse_map(input);
        }

        // 2) If `<` => parse a record
        if input.peek(Token![<]) {
            return parse_record(input);
        }

        // 3) If a leading minus => parse negative number
        if input.peek(Token![-]) {
            let _minus: Token![-] = input.parse()?;
            if input.peek(LitFloat) {
                let lf: LitFloat = input.parse()?;
                return Ok(SdqlValue::NegativeFloat(lf));
            } else if input.peek(LitInt) {
                let li: LitInt = input.parse()?;
                return Ok(SdqlValue::NegativeInt(li));
            } else {
                return Err(syn::Error::new(
                    input.span(),
                    "expected numeric literal after '-'",
                ));
            }
        }

        // 4) If it's a boolean literal `true` / `false`
        if input.peek(LitBool) {
            let lb: LitBool = input.parse()?;
            return Ok(SdqlValue::Bool(lb.value()));
        }

        // 5) If it's an Ident => possibly `date(...)`
        if input.peek(Ident) {
            let ident: Ident = input.parse()?;
            match ident.to_string().as_str() {
                "date" => {
                    let content;
                    syn::parenthesized!(content in input);
                    let inner: LitInt = content.parse()?;
                    return Ok(SdqlValue::Date(inner));
                }
                _ => {
                    return Err(syn::Error::new_spanned(
                        ident,
                        "expected `date(...)` or recognized keyword",
                    ));
                }
            }
        }

        // 6) If it's a numeric literal => parse float or int
        if input.peek(LitFloat) {
            let lf: LitFloat = input.parse()?;
            return Ok(SdqlValue::Float(lf));
        }
        if input.peek(LitInt) {
            let li: LitInt = input.parse()?;
            return Ok(SdqlValue::Int(li));
        }

        // 7) string literal => `"CHINA"`
        if input.peek(LitStr) {
            let ls: LitStr = input.parse()?;
            return Ok(SdqlValue::StringLit(ls));
        }

        Err(syn::Error::new(
            input.span(),
            "unrecognized token in sdql_static!()",
        ))
    }
}

/// Parse a map of the form `{ k -> v, k2 -> v2, ... }`.
fn parse_map(input: ParseStream) -> syn::Result<SdqlValue> {
    let content;
    let _brace = syn::braced!(content in input);

    let mut pairs = Vec::new();
    while !content.is_empty() {
        let key = SdqlValue::parse(&content)?;
        let _arrow: Token![->] = content.parse()?;
        let val = SdqlValue::parse(&content)?;
        pairs.push((key, val));

        if content.peek(Token![,]) {
            content.parse::<Token![,]>()?;
        } else {
            break;
        }
    }

    Ok(SdqlValue::Map(pairs))
}

/// Parse a record of the form `< val1, val2, ... >`.
fn parse_record(input: ParseStream) -> syn::Result<SdqlValue> {
    let _lt: Token![<] = input.parse()?;
    let mut values = Vec::new();

    while !input.peek(Token![>]) {
        values.push(SdqlValue::parse(input)?);
        if input.peek(Token![,]) {
            input.parse::<Token![,]>()?;
        } else {
            break;
        }
    }

    let _gt: Token![>] = input.parse()?;
    Ok(SdqlValue::Record(values))
}

impl SdqlValue {
    fn into_token_stream(self) -> proc_macro2::TokenStream {
        match self {
            SdqlValue::Map(pairs) => {
                let pairs_ts = pairs.into_iter().map(|(k, v)| {
                    let k_ts = k.into_token_stream();
                    let v_ts = v.into_token_stream();
                    quote! { (#k_ts, #v_ts) }
                });
                quote! {
                    ::sdql_runtime::HashMap::from([ #( #pairs_ts ),* ])
                }
            }
            SdqlValue::Record(vals) => {
                let elems = vals.into_iter().map(|v| v.into_token_stream());
                quote! {
                    ::sdql_runtime::Record::new(( #( #elems ),* ))
                }
            }
            SdqlValue::Date(li) => quote! {
                ::sdql_runtime::date!(#li)
            },
            SdqlValue::Bool(true) => quote! { ::sdql_runtime::TRUE },
            SdqlValue::Bool(false) => quote! { ::sdql_runtime::FALSE },
            SdqlValue::Int(li) => quote! { #li },
            SdqlValue::Float(lf) => quote! { ::sdql_runtime::OrderedFloat(#lf) },
            SdqlValue::NegativeInt(li) => quote! { -(#li) },
            SdqlValue::NegativeFloat(lf) => quote! { ::sdql_runtime::OrderedFloat(-#lf) },
            SdqlValue::StringLit(ls) => quote! {
                ::sdql_runtime::VarChar::from(#ls).unwrap()
            },
        }
    }
}
