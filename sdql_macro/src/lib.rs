// TODO clean up â€“ was generated by o-1 https://chatgpt.com/c/67dad45d-8e28-8000-82dd-21dc9e9a4cf3

use proc_macro::TokenStream;
use quote::quote;
use syn::{
    parse::{Parse, ParseStream},
    token, Ident, LitBool, LitFloat, LitInt, Token,
};

/// The user-facing macro entry point.
#[proc_macro]
pub fn sdql_static(input: TokenStream) -> TokenStream {
    // Parse the entire input as a single SdqlValue.
    let parsed = syn::parse_macro_input!(input as SdqlValue);

    // Convert the parsed AST to Rust code.
    let gen = parsed.into_token_stream();
    gen.into()
}

/// Internal AST for our DSL. (No derive to avoid issues with Lit*.)
enum SdqlValue {
    /// e.g. `{ key -> value, key2 -> value2, ... }`
    Map(Vec<(SdqlValue, SdqlValue)>),

    /// e.g. `<val1, val2, ...>` => `Record::new((val1, val2, ...))`
    Record(Vec<SdqlValue>),

    /// e.g. `date(12345)` => `date!(12345)`
    Date(LitInt),

    /// booleans => `TRUE` / `FALSE`
    Bool(bool),

    /// integer literal => e.g. `10691`
    Int(LitInt),

    /// float literal => e.g. `3.14` => `OrderedFloat(3.14)`
    Float(LitFloat),

    /// negative integer => e.g. `-123`
    NegativeInt(LitInt),

    /// negative float => e.g. `-3.14`
    NegativeFloat(LitFloat),
}

impl Parse for SdqlValue {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        // 1) If braces => parse a map: { k -> v, ... }
        if input.peek(token::Brace) {
            return parse_map(input);
        }

        // 2) If `<` => parse a record
        if input.peek(Token![<]) {
            return parse_record(input);
        }

        // 3) If a leading minus => parse negative number
        if input.peek(Token![-]) {
            let _minus: Token![-] = input.parse()?;
            if input.peek(LitFloat) {
                let lf: LitFloat = input.parse()?;
                return Ok(SdqlValue::NegativeFloat(lf));
            } else if input.peek(LitInt) {
                let li: LitInt = input.parse()?;
                return Ok(SdqlValue::NegativeInt(li));
            } else {
                return Err(syn::Error::new(
                    input.span(),
                    "expected numeric literal after '-'",
                ));
            }
        }

        // 4) If it's a boolean literal `true` / `false`
        if input.peek(LitBool) {
            let lb: LitBool = input.parse()?;
            return Ok(SdqlValue::Bool(lb.value()));
        }

        // 5) If it's an Ident => possibly `date(...)`
        if input.peek(Ident) {
            let ident: Ident = input.parse()?;
            match ident.to_string().as_str() {
                "date" => {
                    // parse date(...) => date!(...)
                    let content;
                    syn::parenthesized!(content in input);
                    let inner: LitInt = content.parse()?;
                    // IMPORTANT: return after constructing the SdqlValue!
                    return Ok(SdqlValue::Date(inner));
                }
                _ => {
                    return Err(syn::Error::new_spanned(
                        ident,
                        "expected `date(...)` or recognized keyword",
                    ));
                }
            }
        }

        // 6) If it's a numeric literal => parse int or float
        if input.peek(LitFloat) {
            let lf: LitFloat = input.parse()?;
            return Ok(SdqlValue::Float(lf));
        }
        if input.peek(LitInt) {
            let li: LitInt = input.parse()?;
            return Ok(SdqlValue::Int(li));
        }

        // Otherwise, no match
        Err(syn::Error::new(
            input.span(),
            "unrecognized token in sdql_static!()",
        ))
    }
}

/// Parse a map of the form `{ k -> v, k2 -> v2, ... }`.
fn parse_map(input: ParseStream) -> syn::Result<SdqlValue> {
    let content;
    let _brace = syn::braced!(content in input);

    let mut pairs = Vec::new();
    while !content.is_empty() {
        // parse "key"
        let key = SdqlValue::parse(&content)?;
        // parse "->"
        let _arrow: Token![->] = content.parse()?;
        // parse "value"
        let val = SdqlValue::parse(&content)?;

        pairs.push((key, val));

        // optional comma
        if content.peek(Token![,]) {
            content.parse::<Token![,]>()?;
        } else {
            break;
        }
    }

    Ok(SdqlValue::Map(pairs))
}

/// Parse a record of the form `< val1, val2, ... >`.
fn parse_record(input: ParseStream) -> syn::Result<SdqlValue> {
    let _lt: Token![<] = input.parse()?;
    let mut values = Vec::new();

    while !input.peek(Token![>]) {
        let val = SdqlValue::parse(input)?;
        values.push(val);

        if input.peek(Token![,]) {
            input.parse::<Token![,]>()?;
        } else {
            break;
        }
    }

    let _gt: Token![>] = input.parse()?;
    Ok(SdqlValue::Record(values))
}

// Convert the SdqlValue AST into Rust code via quote!
impl SdqlValue {
    fn into_token_stream(self) -> proc_macro2::TokenStream {
        match self {
            SdqlValue::Map(pairs) => {
                // => HashMap::from([ (k, v), ... ])
                let pairs_ts = pairs.into_iter().map(|(k, v)| {
                    let k_ts = k.into_token_stream();
                    let v_ts = v.into_token_stream();
                    quote! { (#k_ts, #v_ts) }
                });
                quote! {
                    // TODO remove this
                    // ::std::collections::HashMap::from([ #( #pairs_ts ),* ])
                    HashMap::from([ #( #pairs_ts ),* ])
                }
            }
            SdqlValue::Record(vals) => {
                // => Record::new((val1, val2, ...))
                let elems = vals.into_iter().map(|v| v.into_token_stream());
                quote! {
                    Record::new(( #( #elems ),* ))
                }
            }
            SdqlValue::Date(li) => {
                // => date!(nnnn)
                quote! { date!(#li) }
            }
            SdqlValue::Bool(true) => quote! { TRUE },
            SdqlValue::Bool(false) => quote! { FALSE },
            SdqlValue::Int(li) => quote! { #li },
            SdqlValue::Float(lf) => quote! { ::ordered_float::OrderedFloat(#lf) },
            SdqlValue::NegativeInt(li) => quote! { -(#li) },
            SdqlValue::NegativeFloat(lf) => quote! { ::ordered_float::OrderedFloat(-#lf) },
        }
    }
}
